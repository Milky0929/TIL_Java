# 비트 연산자

## 비트 연산자

- 비트 연산자는 논리연산자와 비슷하지만, `비트 단위로 논리 연산을 할 때 사용하는 연산자` 입니다.
- 또한 비트 단위로 왼쪽이나, 오른쪽으로 전체 비트를 이동하거나
- 1의 보수를 만들 때도 사용됩니다.

<br>

|비트 연산자|설명|
|-----------|----|
|\&|대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)|
|\||대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)|
|\^|대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)|
|\~|비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산, 1의 보수)|
|\<\<|명시된 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산)|
|\>\>|부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산)|
|\>\>\>|지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨.|

<br>

- 다음 그림은 비트 And 연산자 (\&)의 동작을 나타냅니다.
- 비트 And 연산자는 대응되는 두 비트가 모두 1일때만, 1을 반환하며, 다른 경우는 모두 0을 반환합니다.

![image](https://github.com/Milky0929/TIL_Java/assets/138620137/c39613b2-e5a1-4b22-834a-7851d7f442d2)

<br>

- 다음 그림은 비트 OR 연산자 (\|)의 동작을 나타냅니다.
- 비트 OR연산자는 대응되는 두 비트 중 하나라도 1이면 1을 반환하며, 두 비트가 모두 0일 때만 0을 반환합니다

![image](https://github.com/Milky0929/TIL_Java/assets/138620137/94a05aa1-275d-468e-b460-bcf665f2762e)

<br>

- 다음 그림은 비트 XOR 연산자 (\^)의 동작을 나타냅니다
- 비트 XOR 연산자는 대응되는두 비트가 서로 다르면 1을 반환하고, 서로 같으면 0을 반환합니다.

![image](https://github.com/Milky0929/TIL_Java/assets/138620137/7fecb2e6-8186-43ca-81e2-0ad41b660bbe)

<br>

- 다음 그림은 비트 NOT연산자 (\~)의 동작을 나타냅니다.
- 비트 NOT 연산자는 해당 비트가 1이면 0을 반환하고, 0이면 1을 반환합니다.

![image](https://github.com/Milky0929/TIL_Java/assets/138620137/ed6b55b4-8de4-4fac-9074-4633a4155231)

<br>

```java
int	num1;
int	num2;

num1 = 8;
num2 = -8;

System.out.println("~ 연산자에 의한 결과:" + ~num1); // -9
System.out.println("<< 연산자에 의한 결과:" + (num1 << 2)); //32
System.out.println(">> 연산자에 의한 결과:" + (num2 >> 2)); //-2
System.out.println(">>> 연산자에 의한 결과:" + (num1 >>> 2)); //2
System.out.println(">>> 연산자에 의한 결과:" + (num2 >>> 2)); // 1073741822
```

<br>

- 1번 예제
	- 비트 반전 연산자(~)는 피연산자의 1의 보수를 반환하므로, 피연산자의 부호만 반대로 변경됩니다.

<br>

- 2번 예제
	- 왼쪽 시프트 연산자(<<)는 지정한 수만큼 피연산자의 모든 비트를 전부 왼쪽으로 이동시킵니다.
	- 이떄 비트의 이동으로 새로 생기는 오른쪽 비트들은 언제나 0으로 채워집니다.
	- 실행 결과를 살펴보면, 모든 비트가 한 비트씩 왼쪽으로 이동할 떄마다 그 값은 2배씩 증가한다는 사실을 알 수 있습니다.
![image](https://github.com/Milky0929/TIL_Java/assets/138620137/9a8ff9cb-9d12-4415-9c60-99982344b714)

<br>

- 3번 예제
	- 오른쪽 시프트 연산자(>>)는 지정한 수만큼 피연산자의 모든 비트를 전부 오른쪽으로 이동시킵니다
	- 이때 비트의 이동으로 새로 생기는 왼쪽 비트들은 언제나 0으로 채워집니다.
	- 따라서 부호는 변하지 않습니다.
	- 실행 결과를 살펴보면, 모든 비트가 한 비트씩 오른쪽으로 이동할 때 마다 그 값은 2배씩 감소한다는 사실을 알 수 있습니다.
![image](https://github.com/Milky0929/TIL_Java/assets/138620137/1d00fa34-3865-45da-8e46-7a5cd6cc13b1)

<br>

- 4번 예제 (양수)
	- 오른쪽 시프트 연산자(>>>)는 부호 비트까지 포함하여 모든 비트를 전부 오른쪽으로 이동시킵니다.
	- 이때 비트의 이동으로 새로 생기는 왼쪽 비트들은 언제나 0으로 채워집니다.
	- 따라서 피연산자가 양수인 경우에는 부호 비트를 이동하지 않는 오른쪽 시프트 연산자(>>)와 같은 결과를 반환합니다.
![image](https://github.com/Milky0929/TIL_Java/assets/138620137/f5bebfda-2519-42a6-9d15-cf7b6ffe5630)

<br>

- 4번 예제 (음수)
	- 하지만 피연산자가 음수인 경우에는 부호 비트까지도 이동하므로, 전혀 다른 결과가 반환됩니다.
	- 다음 그림은 1 바이트의 경우일 때 연산 결과를 나타내며, 위의 예제에서는 총 4바이트일 경우의 연산 결과를 보여줍니다.
	- 따라서 이 시프트 연산자는 10진수의 연산보다는 2진수 연산에서만 주로 사용됩니다.
![image](https://github.com/Milky0929/TIL_Java/assets/138620137/18cbd34a-5d10-4883-ab53-591bedf51dab)


